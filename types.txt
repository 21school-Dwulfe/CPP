
Python 3.x делает четкое различие между типами:

    str= '...'литералы = последовательность символов Unicode (Latin-1, UCS-2 или UCS-4, в зависимости от самого широкого символа в строке )
    bytes= b'...'литералы = последовательность октетов (целые числа от 0 до 255)

Если вы знакомы с:

    Java или 'C#', думайте str как String и bytes как byte[];
    SQL, подумайте str как NVARCHAR и bytes как BINARY или BLOB;
    Реестр Windows, подумайте str как REG_SZ и bytes как REG_BINARY.

Если вы знакомы с C(++), то забудьте все, что вы узнали о char строках, потому что символ — это не байт . Эта идея давно устарела.

Вы используете str, когда хотите представить текст.

print('שלום עולם')

Вы используете bytes, когда хотите представить низкоуровневые двоичные данные, такие как структуры.

NaN = struct.unpack('>d', b'\xff\xf8\x00\x00\x00\x00\x00\x00')[0]

Вы можете закодировать объект str.bytes

>>> '\uFEFF'.encode('UTF-8')
b'\xef\xbb\xbf'

И вы можете декодировать bytesв str.

>>> b'\xE2\x82\xAC'.decode('UTF-8')
'€'

Но вы не можете свободно смешивать эти два типа.

>>> b'\xEF\xBB\xBF' + 'Text with a UTF-8 BOM'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can't concat bytes to str

Обозначение b'...'несколько сбивает с толку, поскольку позволяет указывать байты 0x01-0x7F с помощью символов ASCII вместо шестнадцатеричных чисел.

>>> b'A' == b'\x41'
True

Но я должен подчеркнуть, что символ — это не байт .

>>> 'A' == b'A'
False

В Питоне 2.x

В версиях Python до 3.0 не было такого различия между текстовыми и двоичными данными. Вместо этого было:

    unicode= u'...'литералы = последовательность символов Unicode = 3.xstr
    str= '...'литералы = последовательности смешанных байтов/символов
        Обычно текст, закодированный в какой-то неуказанной кодировке.
        Но также используется для представления двоичных данных, таких как struct.packвывод.

Чтобы упростить переход с 2.x на 3.x, b'...'литеральный синтаксис был перенесен в Python 2.6, чтобы можно было отличать двоичные строки (которые должны быть bytesв 3.x) от текстовых строк (которые должны быть strв 3 ). .Икс). Префикс bничего не делает в версии 2.x, но говорит 2to3сценарию не преобразовывать его в строку Unicode в версии 3.x.

Так что да, b'...'литералы в Python имеют ту же цель, что и в PHP.

    Кроме того, просто из любопытства, существует ли больше символов, чем b и u, которые выполняют другие функции?

Префикс rсоздает необработанную строку (например, r'\t'представляет собой обратную косую черту + tвместо табуляции) и тройные кавычки '''...'''или """..."""разрешает многострочные строковые литералы.
